[P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)

## Floyd 算法 - 邻接矩阵 (70分)

[参考](https://oi-wiki.org/graph/shortest-path/)

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
const int INF=(1<<30);
using namespace std;

const int maxn=1e4+7;
int n,m,s;//点、边、出发点
int f[maxn][maxn];

void floyd(){
    FOR(k,1,n){
        FOR(i,1,n){
            if(i==k or f[i][k]==INF) continue;
            FOR(j,1,n){
                f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
            }
        }
    }
    f[s][s]=0;
}

int main(){
    cin>>n>>m>>s;
    FOR(i,1,n)
        FOR(j,1,n)
            f[i][j]=INF;
    int u,v,w;
    FOR(i,1,m){
        cin>>u>>v>>w;
        f[u][v]=min(f[u][v],w);//去重边
    }
    floyd();
    FOR(i,1,n){
        if(f[s][i]!=INF) cout<<f[s][i]<<" ";
        else cout<<INT_MAX<<" ";
    }
    return 0;
}
```

## Bellman-Ford 算法 - 直接存边 (70分)

[参考](http://www.wutianqi.com/blog/1912.html)

参考代码对于源点的距离赋值顺序有误

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
using namespace std;

const int maxn=1e4+7;
const int maxm=5e5+7;
const int INF=(1<<30);

struct Edge{
    int u,v,w;
};

Edge edge[maxm];
int dist[maxn];//结点到源点最小距离
int n,m,s;//结点数,边数,源点

// 初始化图
void init(){
    FOR(i,1,n)
        dist[i]=INF;
    FOR(i,1,m){
    	int u,v,w;
    	cin>>u>>v>>w;
        edge[i]={u,v,w};
        if(u==s) dist[v]=w;
    }
    dist[s]=0;
}

void relax(int u,int v,int w){
    if(dist[v]>dist[u]+w) dist[v]=dist[u]+w;
}

bool Bellman_Ford(){
    FOR(i,1,n-1)
        FOR(j,1,m)
            relax(edge[j].u,edge[j].v,edge[j].w);
    bool flag=true;
    FOR(i,1,m)//判断是否有负环路
        if(dist[edge[i].v]>dist[edge[i].u]+edge[i].w){
            flag=false;
            break;
        }
    return flag;
}
int main(){
	cin>>n>>m>>s;
    init();
    if(Bellman_Ford()){
        FOR(i,1,n){
            if(dist[i]!=INF) cout<<dist[i]<<" ";
            else cout<<INT_MAX<<" ";
        }
    }
    return 0;
}
```